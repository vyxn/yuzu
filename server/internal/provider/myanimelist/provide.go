// Package myanimelist implements the provider interface for myanimelist metadata
package myanimelist

import (
	"context"
	"encoding/json"
	"fmt"
	"net/url"
	"path"
	"strconv"
	"time"

	"github.com/vyxn/yuzu/internal/pkg/assert"
	"github.com/vyxn/yuzu/internal/pkg/req"
	"github.com/vyxn/yuzu/internal/pkg/yerr"
	"github.com/vyxn/yuzu/internal/standard"
)

const baseURL = "https://api.myanimelist.net/v2/manga"

type MyAnimeListComicInfoProvider struct {
	clientID string
}

func NewMyAnimeListProvider(clientID string) *MyAnimeListComicInfoProvider {
	assert.Assert(
		clientID != "",
		"configure env MYANIMELIST_CLIENT_ID to use this provider",
	)
	return &MyAnimeListComicInfoProvider{clientID}
}

func (p *MyAnimeListComicInfoProvider) ProvideChapter(
	ctx context.Context, series, chapter string,
) (*standard.ComicInfoChapter, error) {
	res, err := p.getComicInfo(ctx, series)
	if err != nil {
		return nil, fmt.Errorf("couldn't get MAL comicinfo: %w", err)
	}

	return res, nil
}

func (p *MyAnimeListComicInfoProvider) getBestMatchID(
	ctx context.Context,
	series string,
) (string, error) {
	u, err := url.Parse(baseURL)
	if err != nil {
		return "", yerr.WithStackf("parsing url %s: %w", baseURL, err)
	}

	params := url.Values{}
	params.Add("q", series)
	u.RawQuery = params.Encode()

	data, err := req.Get(
		ctx,
		u.String(),
		map[string]string{"X-MAL-CLIENT-ID": p.clientID},
	)
	if err != nil {
		return "", err
	}

	type ListResult struct {
		Data []struct {
			Node struct {
				ID          int    `json:"id"`
				Title       string `json:"title"`
				MainPicture struct {
					Medium string `json:"medium"`
					Large  string `json:"large"`
				} `json:"main_picture"`
			} `json:"node"`
		} `json:"data"`
		Paging struct {
			Next string `json:"next"`
		} `json:"paging"`
	}
	var res ListResult
	if err := json.Unmarshal(data, &res); err != nil {
		return "", yerr.WithStackf("unmarshalling json: %w", err)
	}

	for _, m := range res.Data {
		return strconv.Itoa(m.Node.ID), nil
	}

	return "", yerr.WithStackf("not found")
}

func (p *MyAnimeListComicInfoProvider) getComicInfo(
	ctx context.Context,
	series string,
) (*standard.ComicInfoChapter, error) {
	id, err := p.getBestMatchID(ctx, series)
	if err != nil {
		return nil, fmt.Errorf("finding series: %w", err)
	}

	assert.Assert(id != "", "MAL returned empty id")

	u, err := url.Parse(baseURL)
	if err != nil {
		return nil, yerr.WithStackf("parsing url %s: %w", baseURL, err)
	}

	u.Path = path.Join(u.Path, id)

	params := u.Query()
	params.Set(
		"fields",
		"id,title,main_picture,alternative_titles,start_date,end_date,synopsis,mean,rank,popularity,num_list_users,num_scoring_users,nsfw,created_at,updated_at,media_type,status,genres,my_list_status,num_volumes,num_chapters,authors{first_name,last_name},background,serialization{name}",
	)
	u.RawQuery = params.Encode()

	data, err := req.Get(
		ctx,
		u.String(),
		map[string]string{"X-MAL-CLIENT-ID": p.clientID},
	)
	if err != nil {
		return nil, err
	}

	type MangaInfo struct {
		ID          int    `json:"id"`
		Title       string `json:"title"`
		MainPicture struct {
			Medium string `json:"medium"`
			Large  string `json:"large"`
		} `json:"main_picture"`
		AlternativeTitles struct {
			Synonyms []string `json:"synonyms"`
			En       string   `json:"en"`
			Ja       string   `json:"ja"`
		} `json:"alternative_titles"`
		StartDate       string    `json:"start_date"`
		Synopsis        string    `json:"synopsis"`
		Mean            float64   `json:"mean"`
		Rank            int       `json:"rank"`
		Popularity      int       `json:"popularity"`
		NumListUsers    int       `json:"num_list_users"`
		NumScoringUsers int       `json:"num_scoring_users"`
		Nsfw            string    `json:"nsfw"`
		CreatedAt       time.Time `json:"created_at"`
		UpdatedAt       time.Time `json:"updated_at"`
		MediaType       string    `json:"media_type"`
		Status          string    `json:"status"`
		Genres          []struct {
			ID   int    `json:"id"`
			Name string `json:"name"`
		} `json:"genres"`
		NumVolumes  int `json:"num_volumes"`
		NumChapters int `json:"num_chapters"`
		Authors     []struct {
			Node struct {
				ID        int    `json:"id"`
				FirstName string `json:"first_name"`
				LastName  string `json:"last_name"`
			} `json:"node"`
			Role string `json:"role"`
		} `json:"authors"`
		// Pictures []struct {
		// 	Medium string `json:"medium"`
		// 	Large  string `json:"large"`
		// } `json:"pictures"`
		Background    string `json:"background"`
		Serialization []struct {
			Node struct {
				ID   int    `json:"id"`
				Name string `json:"name"`
			} `json:"node"`
		} `json:"serialization"`
	}
	var res MangaInfo
	if err := json.Unmarshal(data, &res); err != nil {
		return nil, yerr.WithStackf("unmarshalling json: %w", err)
	}

	return &standard.ComicInfoChapter{
		Series:  res.Title,
		Summary: res.Synopsis,
		Notes:   "Autogenerated with yuzu üçã",
		Manga:   "YesAndRightToLeft",
	}, nil
}
